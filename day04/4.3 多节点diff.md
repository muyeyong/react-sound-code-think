## 多节点Diff

​	入口：  reconcileChildFibers   -->    reconcileChildrenArray

​	分为两次遍历： 

​		第一轮： 处理更新节点

​		第二轮： 处理剩下的不属于更新的节点

```jsx
function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
    {
      // First, validate keys.
      var knownKeys = null;

      for (var i = 0; i < newChildren.length; i++) {
        var child = newChildren[i];
        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
      }
    }

    var resultingFirstChild = null; // 最终的fiber节点 workInProgress Fiber
    var previousNewFiber = null; // 多节点diff，最终的结果是一条链sibling连接，previousNewFiber是一个中间变量
    var oldFiber = currentFirstChild; // diff的current fiber
    var lastPlacedIndex = 0; // 新创建fiber节点对应的dom节点在页面的索引位置，处理节点位置变化
    var newIdx = 0; // 当前遍历到的jsx对象的索引
    var nextOldFiber = null; // oldFiber的下一个fiber
	}
```



	### 出现情况

​	节点更新

​	节点删除

​	节点位置变化

### 第一轮遍历

​	key变化会直接跳出第一轮遍历，因为第一轮遍历主要是处理更新的节点

​	type变化(li ---> div)创建一个新的fiber节点，effectTag赋值PlaceMent，并把老的fiber标记删除

​		